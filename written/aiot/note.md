一个超出屏幕的处理器
不可能有大规模增长
所有在机器上运行的软件能量密度超过核反应堆
手机性能--电池寿命：功耗问题
单芯片可以集成的处理器数量越来越多了(Logical Cores): 这些核是否有意义呢?

通用计算的时代已经结束了, 性能提升走缓. 非常重要的趋势是处理器变得越来越专用. 并行的特征, 发掘计算模式里面是否有可定制化硬件.
典型例子是 AI 的处理器, 比如华为手机的达芬奇芯片

随着时间演变, 市面上能用到的指令集已经不多了, 很多停止发展了.
通用指令集体系 x86
软硬件实现交互, 融合的概念. 相互借鉴, 比如 x86, 虽然是复杂指令集，但从他的具体指令来说，借用很多RISC 概念和理念;power指令集也引入了`指令组合`的概念, 从逻辑上来看就是和超长指令集思路上是相通的。

2000年 单核优化是编译技术的重点，比如循环优化，数据识别，`编译器本身的优化是和处理器实现紧密相关的`, 
随着多核处理器的发展，编译器的优化转向了它。而性价比是很重要的指标，当单核性能到一定程度时，不得不通过多核提高性能，(2008)
2010后性能提升走向异构的优化。异构的多核就是现在处理器的形态从CPU转向GPU以及现在的AI芯片，我们现在已经在一个异构计算的定制化时代。FPGA等.
对编译优化来说，面对的是对不同的软件怎么协作来做有意义的计算。 异构/超异构时代
对软件开发效率和兼容性提出了前所未有的挑战——软件灾难时代，怎么让不同软件在不同芯片并行起来：例子：天河2集成了不同CPU,GPU集群，如何让他们协同起来。 TPU是谷歌推出针对AI计算的，用他自己的指令集，是针对领域定制的。不再是仅有CPU和GPU，甚至以后还有XPU(X只是表示未知hhh)
从开发者视角：不同处理器有不同的开发技巧(优化技巧)，
异构处理器核之间的兼容性也是个问题：这软件是否可以跑在不同的处理器上。二进制兼容。 源代码兼容性当前已经是一个非常大的挑战了，例子：NVIDIA GPU的开发，用了通用的OPENCL开发，可以针对不同的GPU用同种编程语言开发，但是性能并不能够保证一致(最高). 这导致保证了代码兼容性，但又不能保证代码性能，因此软件移植代价非常高

##### 问题解决——产业案例

声明式开发: 所见即所得(UI即代码, 代码即UI)的可视化编程， 比如word就是所见即所得的文本编辑。
协同式开发: 多人协作/端云协同编程。大规模的开发经常是有上百个开发者，如何让大规模团队同时做有效的事情。实时的也有些问题。
智慧化开发：AI辅助编程/AI可视化编程。现在有一些代码提示，但他们是代码逻辑上的提示。未来时代可以推断出对代码性能的评估，智能化编程能够在编程过程就知道代码效果，包括性能，安全等。
化为59.8S 完成ResNet-50，现场展示了基于mindspore实现10.02s识别20万天体。
superkernel优化技术，解决了最终编译出来的软件的问题。解决的是如何把我需要构建的软件编译出来。
编译解决了性能问题和代码开发时间问题
- superkernel 优化禁止：
- 并行编译,ccache优化
- 算子编译优化和代码生成技术

###### 方舟编译器
通过方舟编译器解决用户体验问题。
- JAVA全静态化编译技术，基于统一IR
- JAVA RC内存管理
- JNI自动拆墙优化

##### 技术案例分享
编译器编程语言的设计和实现在关注什么问题：
设计：语法语义：
1. 表达能力强：容易描述计算，业务逻辑
2. 容易使用，好学好写好读
3. 不易出错，代码安全

编译器有哪些考量：实现：让芯片看懂并执行：
1. 运行时间短
2. 占用资源少
3. 平台无关，移植性

要让app能在尽可能多的手机平台上运行，才能获取更多用户，这如何通过编译过程解决？

###### 编译的基本过程
- 源代码
- 词法解析，语法解析：识字
  - 语义检查：前后通顺与否----然后得到抽象语法树
  - 编译：代码生成和优化： 把原有逻辑进行等价代换，这是非常关键的优化过程。
    - 字节码：虚拟机
    - 二进制：处理器

中间涉及
- 代码生成和优化算法
- 虚拟机/解释器执行引擎
- 线程/协程/事件管理
- 垃圾收集
- 中间表示/字节码设计

###### 三种执行方式的区别

- 解释执行：说一句，做一句
- 编译执行：完整编译为机器可执行的二进制编码，这是一次性的，静态的编译，特点是快。
- 字节码虚拟机：java，把程序，源代码编译成字节码，原则上与处理器/微处理器不相关，由虚拟机执行，不是通常意义上在PC机里可以启动的虚拟PC机，而是用来运行字节码的，虚拟的字节码机器。
  - 实时编译：JIT(just in time), 
  - 可以把热点代码编译成机器指令

###### 方舟编译器
跨平台的编译平台，内部由运行环境引擎，可以把方舟编译器编译出来的运行在不同机器上，当前支持C和JAVA
获得性能的原理是：跨语言调用的开销
字节码是在语言虚拟机执行
实际应用中会需要调用由C代码实现的程序的时候，两者之间必须跨越语言上的鸿沟，需要有一个转换的过程, 这就是`JNI墙`, 这个调用过程会耗用额外的计算开销

MAPLE(方舟内部执行引擎): 把不同语言的都统一到一个中间表达，由统一的表达进行统一的优化，就不需要额外的开销，静态生成的可执行文件，手机APP就不再需要转换。
那么`关键来到了如何定义这么一种中间语言`: 

`AUTO-Tuning技术`: 
- 通过静态翻译获得软件最优性能的障碍
  - 编译器的优化策略有非常多参数，经过非常多变换过程，每一个变换都有一个特定的策略。比如循环展开：程序有一个循环要执行多次，每一次跳转对处理器来说都有额外开销，不用跳转的方式完成循环，而是复制为多份，这样就不用跳转。
  - 不同参数组合有不同的策略，静态生成的话问题在于如何组合？固定且单一的策略难以适应不同软件的特征。不同执行环境可能要不同的参数，所以`单一编译出来的策略并不能让所有平台上都达到最优`。而且`已发布程序无法进一步优化`
- auto-tuning技术: 让编译策略更加优，更加好地适配运行环境，自动评估优化效果
  - Tuning-enabled 编译器
  - search driver
  - prfiler(static/dynamic)
- 流程:
  - 内部的一些编译策略和需要调整的参数完全暴露给外部的控制程序(driver)。
  - 第一步编译到可执行程序
  - 然后运行程序/仿真程序，以做评估，来告知自动调优过程达到了怎样的性能水准
  - profiler作用就是识别当前的执行是否是一个高效的执行。经过统计了包括访存时延，性能高效性等，就把这些信息交给profiler评估
  - 接下去就是search driver的工作， 收集完信息后，给出通过profiler评估后的结果来给出下一步的更优参数
  - 当完成搜索，就达到了闭环，然后不断迭代。本质上是NP完备的问题。

###### 优化案例：如何使用一个既定指定针对场景进行优化。可以通过特定场景的问题来设计。
如何使用一个128bit位宽的原子操作来优化。数据库应用中，有大量的数据在多核。这么多核我们需要为了保证数据库应用一致性，需要并发地对数据库内部数据进行读写，通过自旋锁来操作。比如要对日志系统的日志进行读写，某一个处理器核要对数据进行修改的时候，必须抢到这个锁，只有抢到这把锁的处理器才能对数据进行修改，改完还要释放，才能保证读写是不会受干扰的。每次读写都要抢一次，就会造成非常多的冲突。原来在数据库场景所用数据是128位数据，但锁是单个字节的，不能对128位的操作。现在有这个就可以只抢一次就完成对这个数据的操作。简单说就是可以一次保护128位。这样系统上的冲突几率，至少对于一个的操作的，就减少了。仅仅这一个修改就可能对数据库性能提升10%.

无锁数据结构的修改：boost库等软件栈有高并发场景。需要加解锁的方式来操作也会产生类似的加锁修改解锁的过程。通过128bit位宽原子指令操作。。。。基本上就是说把锁对性能影响展现到极致的benchmark程序`xxx`, 能产生巨大的性能差异，而且线程数-性能提升有个表(很牛逼的样子, 总之处理器核越多性能影响越大).

- 指令能怎样提升软件
- 软件对特定功能有诉求，要什么样的指令

###### 挑战课题

1. 通用编程语言的扩展机制研究，以及新型AI编程语言的设计和实现
    重点突破编程语言核心技术：
    1. 探索构建通用编程语言各种可扩展机制的设计和实现：包括但不限于元编程，跨语言互操作，eDSL以及其类型系统，可扩展编译器框架
    2. 新型AI编程语言设计和实现：基于可扩展通用编程语言，构建一套面向AI算法开发的编程语言，实现语言原生自动微分，动静态图融合，稀疏矩阵编程等核心技术。

2. 基于开放体系架构下的DSA设计与编译工具链技术研究：针对不同场景应用都代表了对芯片不同的需求，能否定制不同应用所需要的架构。

3. 针对特定芯片编译器的研究:如何把软件运行在芯片上，这是和芯片开发研究同步进行的，问题是如何同步？
4. 面向应用的统一化（公共中间表示）的研究：超异构的时代有非常多不同类型的核，处理器等。如何统一地采用中间表达来满足不同类型的应用的编程。在芯片层级我们也希望这种统一的表达。从中间表达去实现这种表达。统一的中间表达对整个超异构芯片进行编程。