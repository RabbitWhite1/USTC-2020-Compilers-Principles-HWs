# H9

## 1
### 1)
我直接复制 H2 的解答过来了:

- 用`man gcc`来查询, 发现这个参数的含义是`Do not search the standard system directories for header files.  Only the directories you have specified with -I options (and the directory of the current file, if appropriate) are searched.`  
- 用中文解释一下也就是, 编译的时候不去搜索头文件的标准系统路径, 这样一来自然就找不到`stdio.h`的包含路径, 从而引发编译错误.

一般是 `-E` 的预处理阶段就检查.

### 2)
#### 检查大小
```shell
rabbit@DESKTOP-CK1FK5P:~$ gcc -o link-s -static link2.c link1.c
rabbit@DESKTOP-CK1FK5P:~$ gcc -o link link2.c link1.c
rabbit@DESKTOP-CK1FK5P:~$ du -sh link*
32K     link
1.2M    link-s
```
#### objdump 和 nm 的结果

- link-s: 显然它把所有涉及的函数都静态地加到了文件里, 因此它符号也特别多
  - 好处:
    - 在没有动态库的情况下也能运行
  - 坏处:
    - 占的空间大
- link: 则以动态加载库的方式进行调用, 只有几个关键的符号
  - 好处:
    - 所占空间小
  - 坏处
    - 没有动态库则无法运行

### 3)
`_start` 是一个程序的起始标签, 链接时当然要找到它. 这是在 `链接` 的阶段发生的(printf那个也是)

### 4)

#### 64 位

段错误.
原本 buf 位置是一个数组, 其第一个元素值为 100.
现在 `link2.c` 单纯地去引用 `buf` 这个符号, 就会以为 `buf` 是个指针, 其值为 100, 这时候去访问地址为 100 的空间一般来说是访问到了内核态的内存, 因此会报段错误

#### 32 位
