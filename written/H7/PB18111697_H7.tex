\documentclass[UTF8]{article}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{makecell}
\usepackage[utf8]{inputenc}
\usepackage[space]{ctex} %中文包
\usepackage{listings} %放代码
\usepackage{xcolor} %代码着色宏包
\usepackage{CJK} %显示中文宏包
\usepackage{float}
\usepackage{diagbox}
\usepackage{bm}
\usepackage{ulem} 
\usepackage{amssymb}
\usepackage{soul}
\usepackage{color}
\usepackage{geometry}
\usepackage{fancybox} %花里胡哨的盒子
\usepackage{xhfill} %填充包, 可画分割线 https://www.latexstudio.net/archives/8245
\usepackage{multicol} %多栏包
\usepackage{enumerate} %可以方便地自定义枚举标题
\usepackage{multirow} %表格中多行单元格合并
\usepackage{wasysym} %可以使用wasysym里的一堆奇奇怪怪的符号
\usepackage{hyperref} % url
%%%%%%%%%%%%%%%伪代码%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%%%%%%%%%%%%%%%画图包%%%%%%%%%%%%%%%
\usepackage{tikz}
\usepackage{pgfplots} % http://pgfplots.sourceforge.net/gallery.html
\usetikzlibrary{pgfplots.patchplots} % 拟合支持
\usetikzlibrary{arrows,shapes,automata,petri,positioning,calc} % 状态图支持
\usetikzlibrary{arrows.meta} % 箭头
\usetikzlibrary{shadows} % 阴影支持
\usepackage{forest} % 画树

\geometry{left = 1.5cm, right = 1.5cm, top=1.5cm, bottom=2cm}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
	backgroundcolor=\color{white}, 
	%\tiny < \scriptsize < \footnotesize < \small < \normalsize < \large < \Large < \LARGE < \huge < \Huge
	basicstyle = \footnotesize,       
	breakatwhitespace = false,        
	breaklines = true,                 
	captionpos = b,                    
	commentstyle = \color{mygreen}\bfseries,
	extendedchars = false,
	frame = shadowbox, 
	framerule=0.5pt,
	keepspaces=true,
	keywordstyle=\color{blue}\bfseries, % keyword style
	language = C++,                     % the language of code
	otherkeywords={string}, 
	numbers=left, 
	numbersep=5pt,
	numberstyle=\tiny\color{mygray},
	rulecolor=\color{black},         
	showspaces=false,  
	showstringspaces=false, 
	showtabs=false,    
	stepnumber=1,         
	stringstyle=\color{mymauve},        % string literal style
	tabsize=4,          
	title=\lstname           
}

%\sum\nolimits_{j=1}^{M}   上下标位于求和符号的水平右端，
%\sum\limits_{j=1}^{M}   上下标位于求和符号的上下处，
%\sum_{j=1}^{M}  对上下标位置没有设定，会随公式所处环境自动调整。

%%%%%%%%%%%%%画图包%%%%%%%%%%%%%
\usepackage{tikz}
%%%%%%%%%%%%%好看的矩形%%%%%%%%%%%%%
\tikzset{
  rect1/.style = {
    shape = rectangle,% 指定样式
    minimum height=2cm,% 最小高度
    minimum width=4cm,% 最小宽度
    align = center,% 文字居中
    drop shadow,% 阴影
  }
}
%%%%%%%%%%%%%画图背景包%%%%%%%%%%%%%
\usetikzlibrary{backgrounds}

%%%%%%%%%%%%%在tikz中画一个顶点%%%%%%%%%%%%%
%%%%%%%%%%%%%#1:node名称%%%%%%%%%%%%%
%%%%%%%%%%%%%#2:位置%%%%%%%%%%%%%
%%%%%%%%%%%%%#3:标签%%%%%%%%%%%%%
\newcommand{\newVertex}[3]{\node[circle, draw=black, line width=1pt, scale=0.8] (#1) at #2{#3}}
%%%%%%%%%%%%%在tikz中画一条边%%%%%%%%%%%%%
\newcommand{\newEdge}[2]{\draw [black,very thick](#1)--(#2)}
%%%%%%%%%%%%%在tikz中放一个标签%%%%%%%%%%%%%
%%%%%%%%%%%%%#1:名称%%%%%%%%%%%%%
%%%%%%%%%%%%%#2:位置%%%%%%%%%%%%%
%%%%%%%%%%%%%#3:标签内容%%%%%%%%%%%%%
\newcommand{\newLabel}[3]{\node[line width=1pt] (#1) at #2{#3}}

%%%%%%%%%%%%%强制跳过一行%%%%%%%%%%%%%
\newcommand{\jumpLine} {\hspace*{\fill} \par}
%%%%%%%%%%%%%关键点指令,可用itemise替代%%%%%%%%%%%%%
\newcommand{\average}[1]{\left\langle #1\right\rangle }
%%%%%%%%%%%%%表格内嵌套表格%%%%%%%%%%%%%
\newcommand{\keypoint}[2]{$\bullet$\textbf{#1}\quad#2\par}
%%%%%%%%%%%%%<T>平均值表示%%%%%%%%%%%%%
\newcommand{\tabincell}[2]{\begin{tabular}{#1}#2\end{tabular}}%放在导言区
%%%%%%%%%%%%%大黑点item头%%%%%%%%%%%%%
\newcommand{\itemblt}{\item[$\bullet$]}
%%%%%%%%%%%%%大圈item头%%%%%%%%%%%%%
\newcommand{\itemc}{\item[$\circ$]}
%%%%%%%%%%%%%大星星item头%%%%%%%%%%%%%
\newcommand{\itembs}{\item[$\bigstar$]}
%%%%%%%%%%%%%右▷item头%%%%%%%%%%%%%
\newcommand{\itemrhd}{\item[$\rhd$]}
%%%%%%%%%%%%%定义为%%%%%%%%%%%%%
\newcommand{\defas}{=_{df}}
%%%%%%%%%%%%%偏导%%%%%%%%%%%%%
\newcommand{\partialx}[2]{\frac{\partial #1}{\partial #2}}
%%%%%%%%%%%%%蕴含%%%%%%%%%%%%%
\newcommand{\imp}{\rightarrow}
%%%%%%%%%%%%%上取整%%%%%%%%%%%%%
\newcommand{\ceil}[1]{\lceil#1\rceil}
%%%%%%%%%%%%%下取整%%%%%%%%%%%%%
\newcommand{\floor}[1]{\lfloor#1\rfloor}
%%%%%%%%%%%%%textbullet%%%%%%%%%%%%%
\newcommand{\blt}{\bullet}
%%%%%%%%%%%%%右箭头上加字%%%%%%%%%%%%%
\newcommand{\righttextarrow}[1]{\stackrel{#1}{\longrightarrow}}
%%%%%%%%%%%%%左箭头上加字%%%%%%%%%%%%%
\newcommand{\lefttextarrow}[1]{\stackrel{#1}{\longleftarrow}}

%%%%%%%%%%%%%双线分割线%%%%%%%%%%%%%
\newcommand*{\doublerule}{\hrule width \hsize height 1pt \kern 0.5mm \hrule width \hsize height 2pt}
%%%%%%%%%%%%%双线中间可加东西的分割线%%%%%%%%%%%%%
\newcommand\doublerulefill{\leavevmode\leaders\vbox{\hrule width .1pt\kern1pt\hrule}\hfill\kern0pt }
%%%%%%%%%%%%%左大括号%%%%%%%%%%%%%
\newcommand{\leftbig}[1]{\left\{\begin{array}{l}#1\end{array}\right.}
%%%%%%%%%%%%%矩阵%%%%%%%%%%%%%
\newcommand{\mat}[2]{\left[\begin{array}{#1}#2\end{array}\right]}
%%%%%%%%%%%%%可换行圆角文本框%%%%%%%%%%%%%
\newcommand{\ovalboxn}[1]{\ovalbox{\tabincell{l}{#1}}}
%%%%%%%%%%%%%设置section的counter, 使从1开始%%%%%%%%%%%%%
\setcounter{section}{0}

%%%%%%%%%%%%%Colors%%%%%%%%%%%%%
\newcommand{\lightercolor}[3]{% Reference Color, Percentage, New Color Name
    \colorlet{#3}{#1!#2!white}
}
\newcommand{\darkercolor}[3]{% Reference Color, Percentage, New Color Name
    \colorlet{#3}{#1!#2!black}
}
\definecolor{aquamarine}{rgb}{0.5, 1.0, 0.83}
\definecolor{Seashell}{RGB}{255, 245, 238} %背景色浅一点的
\definecolor{Firebrick4}{RGB}{255, 0, 0}%文字颜色红一点的
\lightercolor{gray}{15}{lgray}
\newcommand{\hlg}[1]{
	\begingroup
		\sethlcolor{lgray}%背景色
		\textcolor{black}{\hl{\mbox{#1}}}%textcolor里面对应文字颜色
	\endgroup
}



\title{编译原理与技术 H7}
\date{}
\author{PB18111697 王章瀚}

\begin{document}
\maketitle
\section*{.}
\noindent 请写出下面的变量a的类型表达式
\begin{lstlisting}
int a[][3];
int *a[3];
int (*a)[3];
int *(*a)[3];
int **a[3];
\end{lstlisting}
\noindent a.type应为:
\begin{enumerate}[1. ]
	\item array(?,array(3,int)), 这里用?表示是因为确实不知道大小, 比如在C中直接这样写会报错.\\
	(或者干脆写成pointer(array(3,int)))
	\item array(3,pointer(int))
	\item pointer(array(3,int))
	\item pointer(array(3,pointer(int)))
	\item array(3,pointer(pointer(int)))
\end{enumerate}

\section*{教材5.6}
\noindent 下列文法定义字面常量表的表. 符号的解释和图5.2文法的那些相同, 增加类型list, 它表示类型T的元素表.

$$\begin{array}{l}
P \rightarrow D; E\\
D \rightarrow D; D | id : T\\
T \rightarrow list\ of\ T | char | integer\\
E \rightarrow (L) | literal | num | id | nil\\
L \rightarrow E, L | E
\end{array}$$
\noindent 写一个类似5.3节中的翻译方案, 以确定表达式(E)和表(L)的类型.\\

\noindent 可以写成:
$$\begin{array}{ll}
P \rightarrow D;E \\
D \rightarrow D;D \\
D \rightarrow id:T & \{addtype(id.entry,T.type);\}\\
T \rightarrow list\ of\ T_1 & \{T.type=list(T_1.type)\} \\
T \rightarrow char & \{T.type=char;\} \\
T \rightarrow integer & \{T.type=integer;\} \\
E \rightarrow (L) & \{E.type=list(T.type)\}\\
E \rightarrow literal & \{E.type=char\} \\
E \rightarrow num & \{E.type=integer;\} \\
E \rightarrow id & \{E.type=looup(id.entry);\} \\
E \rightarrow nil & \{E.type=list(?)\}\\
L \rightarrow E, L_1 & \{L.type=if(L_1.type==E.type)L_1.type\ else\ type_error\} \\
L \rightarrow E & \{L.type=E.type\} \\
\end{array}$$

\section*{教材5.15}
\noindent 找出下列表达式的最一般的合一代换:
\begin{enumerate}[(a) ]
	\item $(pointer(\alpha))\times(\beta\rightarrow\gamma)$
	\item $\beta\times (\gamma\rightarrow\delta)$
\end{enumerate}
\noindent 如果(b)的$\delta$是$\alpha$呢?
\begin{enumerate}[(1). ]
	\item 原来的: 最一般的合一代换就是
	$$\begin{array}{l}
		S(\beta)=(pointer(\alpha))\\
		S(\gamma)=(pointer(\alpha))\\
		S(\delta)=(pointer(\alpha))
	\end{array}$$
	最后能代换成:
	$$(pointer(\alpha))\times(pointer(\alpha)\rightarrow pointer(\alpha))$$
	\item 如果(b)的$\delta$是$\alpha$, 就变成
	\begin{enumerate}[(a) ]
		\item $(pointer(\alpha))\times(\beta\rightarrow\gamma)$
		\item $\beta\times (\gamma\rightarrow\alpha)$
	\end{enumerate}
	这时它不存在合一代换. 因为如果要合一, 就要有
	$$\begin{array}{l}
		S(\beta)=S(pointer(\alpha))\\
		S(\beta)=S(\gamma)\\
		S(\gamma)=S(\alpha)
	\end{array}$$
	从而需要$S(\alpha)=S(pointer(\alpha))$, 这要求一个类型的指针类型依然是这个类型, 显然不合理.
\end{enumerate}

\section*{教材5.17}
\noindent 效仿例5.5, 推导下面map的多态类型:
$$map: \forall\alpha.\forall\beta.((\alpha\rightarrow\beta)\times list(\alpha))\rightarrow list(\beta)$$
\noindent map的ML定义是:
\begin{lstlisting}
fun map(f,l)=
	if null (l) then nil
	else cons(f(hd(1)), map(f,tl(l)));
\end{lstlisting}
在这个函数体中, 内部定义的标志符类型是:
$$\begin{array}{l}
	null:\forall\alpha.list(\alpha)\rightarrow boolean;\\
	nil:\forall\alpha.list(\alpha);\\
	cons:\forall\alpha.(\alpha\times list(\alpha))\rightarrow list(\alpha);\\
	hd:\forall\alpha.list(\alpha)\rightarrow\alpha;\\
	tl:\forall\alpha.list(\alpha)\rightarrow list(\alpha);
\end{array}$$
\noindent 答:\\
整个推导过程如下:\\
\begin{center}
\begin{tabular}{l|l|l|l}
	\hline
	行 & 定型断言 & 代换 & 规则 \\
	\hline
	1 & $f:\gamma$ &  & Exp Id \\
	\hline
	2 & $l:\delta$ &  & Exp Id \\
	\hline
	3 & $map: \epsilon$ &  & Exp Id \\
	\hline
	4 & $map(f,l): \zeta$ & $\epsilon=\gamma\times\delta\rightarrow\zeta$ & Exp FunCall\\
	\hline
	5 & $null:list(\alpha_1)\rightarrow boolean$ &  & Exp Id Fresh \\
	\hline
	6 & $null(l):boolean$ & $\delta=list(\alpha_1)$ & Exp FunCall \\
	\hline
	7 & $nil:list(\alpha_2)$ &  & Exp Id Fresh \\
	\hline
	8 & $hd:list(\alpha_3)\rightarrow\alpha_3$ &  & Exp Id Fresh \\
	\hline
	9 & $hd(l):\alpha_3$ & $\alpha_3=\alpha_1$ & Exp FunCall \\
	\hline
	10 & $f(hd(l)):\alpha_4$ & $\gamma=\alpha_1\rightarrow\alpha_4$ & Exp FunCall \\
	\hline
	11 & $tl: list(\alpha_5)\rightarrow list(\alpha_5)$ &  & Exp Id\\
	\hline
	12 & $tl(l):list(\alpha_5)$ & $\alpha_5=\alpha_1$ & Exp Id\\
	\hline
	13 & $map(f,tl(l)):\zeta_1$ & $\zeta_1=\zeta$ & Exp FunCall \\
	\hline
	14 & $cons:(\alpha_6\times list(\alpha_6))\rightarrow list(\alpha_6)$ &  & Exp Id Fresh \\
	\hline
	15 & $cons(f(hd(l)), map(f,tl(l))):list(\alpha_6)$ & $\alpha_6=\alpha_4$ & Exp FunCall \\
	 &  & $\zeta=list(\alpha_4)$ & \\
	\hline
	16 & $if\ boolean\times\lambda\times\lambda\rightarrow\lambda$ & $\lambda=list(\alpha_4)$ & Exp Id Fresh \\
	\hline
	17 & $if(...):list(\alpha_4) $ & $\alpha_4=\alpha_2$ & Exp FunCall \\
	\hline
	18 & $match: \mu\times\mu\rightarrow\mu$ &  & Exp Id Fresh \\
	\hline
	19 & $match(...):list(\alpha_2)$ & $\alpha_8=\alpha_2$ & Exp FunCall \\
	\hline
\end{tabular}
\end{center}
这样, 就推断出来了
$$\begin{array}{l}
	f:\alpha_1\rightarrow \alpha_4\\
	l:list(\alpha_1)\\
	map:((\alpha_1\rightarrow \alpha_4)\times list(\alpha_1))\rightarrow list(\alpha_4)
\end{array}$$
从而有$$map: \forall\alpha.\forall\beta.((\alpha\rightarrow\beta)\times list(\alpha))\rightarrow list(\beta)$$



\end{document}





