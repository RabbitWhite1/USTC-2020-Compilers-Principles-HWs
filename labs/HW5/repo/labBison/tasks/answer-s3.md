# HW5-Step3

## 问题1. 理解规则中嵌入的动作，是继承属性还是综合属性？

### 问题
请问：
1. 上述`input`规则中第2行的动作与第5行的动作分别相当于继承属性还是综合属性，Bison对这两个嵌入动作是怎么处理的？请查阅bison生成的`src/exprL.output`进行说明。,

2. 根据`./run.sh exprL expr.in`的输出结果，请说明词法分析和语法分析的交替过程，解释输出的第1个行中`3`在`Line 1:`之前的原因。

3. 请修改`config/exprL-s3.y`，使之能在解析每行前输出行号信息，即先后执行`make exprL-s3`和`./run.sh exprL-s3 expr.in`后，输出：

### 回答
1. 第2行的动作相当于继承属性(从input1得到); 第5行的动作也是继承属性(从input1和input2得到). 这被嵌入的动作被做成了一个`非终结符`(但他们都是%empty)来处理.
2. 这是因为文件首先进行了词法分析以获取一个符号, 从而才有机会去做文法分析, 所以在这里就表现为, 先读取了第一个数字 `3`, 然后相间地去做了语法分析, 从而输出行号信息, 只当需要下一个符号时, 才再调用词法分析去分析下一个符号.
3. 我的解答是上述第一种. 主要思路就是要输出后缀表达式只需要(以双目算符为例)让整个表达式左右子表达式都解析并输出完后, 再输出该表达式的运算符即可.

## 问题2. 使用并理解用Bison构造中缀表达式到逆波兰式的转换

虽然这个文法是二义的, 但其优先级都被规定好了(`.output`文件也有详述), 因此实际上能够正常解析, 既然能够正常解析, 也就能够正确输出逆波兰式.

## 问题3. 分析用Bison构造中缀表达式到波兰式转换中的问题

1. 产生冲突的原因: 因为 `%empty` 可以规约成 `exp`, 也可以规约成各个警告中提到的 `{printf(...);}`(这些表达式对应了非终结符 `$@n`, 而它们又都有 `$@n→%empty`). 所以就产生了规约规约冲突. 同时, 这个问题也导致了相关的移进规约冲突.
2. 能够生成可执行文件是因为这些规则直接被弃用了, 只有剩余少数规则仍起作用(比如不断输入回车换行), 但依然可以由这些少数规则构成这个可执行文件.
3. 报语法错误的原因: 根据2所解释, 那些冲突了的规则并未被加入可执行文件, 故输入不存在的规则模式时, 自然会报 `syntax error`.

## 问题4. 用Bison构造中缀表达式到波兰式转换器

主要构造思路就是构造一个属性表示该符号的波兰表达式, 例如 `exp1->exp2 + exp3`, 就先把 `exp2` 和 `exp3` 的波兰表达式算出来, 然后规约成 `exp1`, 将 `exp1` 的波兰表达式赋值为 `+ exp1的波兰表达式 exp2的波兰表达式`, 以此类推.

样例首先有助教给出的 `expr.in`:
```bash
3**2**3

	
48+2**2**3
56+78*3+--8+-2
```

然后我自己构造了几个:
```bash
(1+5)*2 # 检查括号
-5*2 # 检查负号
-(5-2) # 验证issue里的问题
-(5)-2 # 验证issue里的问题, 确实其波兰表达式都是一样的.
```
