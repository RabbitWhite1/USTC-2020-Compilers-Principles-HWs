# HW5-step2

## 问题1

### 问题

1、请用`-r solved`选项执行bison，将在`src`目录输出文件`expr.output`，其中`State 9`的定义如下：

```bash
State 9

    6 exp: exp . PLUS exp
    7    | exp . MINUS exp
    8    | exp . MULT exp
    9    | exp . DIV exp
   10    | MINUS exp .
   11    | exp . EXPON exp

    $default  reduce using rule 10 (exp)

    Conflict between rule 10 and token PLUS resolved as reduce (PLUS < UMINUS).
    Conflict between rule 10 and token MINUS resolved as reduce (MINUS < UMINUS).
    Conflict between rule 10 and token MULT resolved as reduce (MULT < UMINUS).
    Conflict between rule 10 and token DIV resolved as reduce (DIV < UMINUS).
    Conflict between rule 10 and token EXPON resolved as reduce (EXPON < UMINUS).
```
该状态包含5条冲突，请解释这些冲突产生的原因以及Bison对这些冲突的解决。

### 解答

#### 冲突原因

生成的 `expr.output` 正如题述.  
这些冲突警告的都是关于移进规约冲突的, 且原因一致, 以
```bash
Conflict between rule 10 and token PLUS resolved as reduce (PLUS < UMINUS).
```
为例, 其意为 `rule 10` 与 `PLUS` 终结符有移进规约冲突. 这是因为在该状态下, 即可按照 `rule 10` 进行规约, 也可以对 `PLUS` 进行移进. 因此产生了冲突.

#### Bison对冲突的解决

Bison在这种情况下用规约解决(`resolved as reduce`). 即使用产生式10作规约. 这是因为在 `.y` 文件中定义了优先级: `PLUS<UMINUS`.

## 问题2

### 问题
阅读bison产生的分析器源码`expr.tab.c`，回答：
- 指出以下符号的含义：`yyss`、`yyvs`、`yyn`、`yytoken`、`yyval`、`yydefact`、`yydefgoto`、`yytable`、`yycheck`、`yypact`、`yypgoto`；
- 简述`yyparse()`的主要流程，指出标号`yysetstate`、`yybackup`、`yydefault`、`yyreduce`处的代码主要在做什么方面的处理

### 回答

`yyss`: 这个变量和 `yyssa` 数组(状态栈)配合使用, `yyss` 为其基址, 除非出现溢出(overflow), 否则它不会改变(溢出时需要重新分配数组, 因此会改变); `yyssp` 则是相应栈顶指针.
- `yyvs`: 与 `yyss` 不同的是, 它用于保存 `语义值`. 同样也有 `yyvsp` 和 `yyvsa`
- `yyn`: 这仅仅是个变量, 可能表示状态序号或者产生式序号
- `yytoken`
- `yyval`: 在其定义处(`YYSTYPE yyval`)有注释
    > The variables used to return semantic value
    其意为该变量用以返回语义值
- `yydefact`: 用来表示该状态下默认的规约产生式, 即决定了课本上表中的 `r#`(#是该产生式序号, 即 `yydefact[state-num]`)
- `yydefgoto`: `yydefgoto[index]` 表明了第 index 个非终结符的默认GOTO状态.
- `yytable`: 用来表示移进后下一个状态是什么 或 应使用什么样的产生式规约, 如果为正, 则进行移进; 若为负, 则按其相反数对应的产生式进行规约; -1表示错误
- `yycheck`: 用以指导使用 `yypgoto` 还是 `yydefgoto`. 
- `yypact`: 如果 `yypact[cur-state]` 为 `YYPACT_NINF`, 那么就应该使用 `yydefact`; 否则将这个值加到向前看符号序号, 并用加法结果来查询 `yytable`(也就是用索引号 `yypact[cur-state]+#lookahead-token` 查询 `yytable`)， 以此决定要规约还是移进(根据正负).
- `yypgoto`: 对于刚刚规约了的产生式左部, 其在 `yypgoto` 有一个值, 将这个值加到因为规约而暴露出来的状态序号值上得到index, 即可得到规约结果的状态值为 `yytable[index]`.

另外
- `yystos`: YYSTOS[STATE-NUM] -- The (internal number of the) accessing symbol of state STATE-NUM. 
- `yyr1[yyn]`: Symbol number of symbol that rule YYN derives
- `yyr2[yyn]`: Number of symbols on the right hand side of rule YYN

### yyparse 的主要流程

1. 第一部分定义了栈及栈指针, 各种其他变量.
2. 然后进入 `yysetstate` 来设置栈顶状态, 这主要是通过
    ```c
    *yyssp = YY_CAST (yy_state_t, yystate);
    ```
    完成
    此外, 这其中还包括了 `overflow` 的相关判断及扩栈代码.
3. 接下来进入后续处理 `yybackup`. 这一步是关键处理步骤, 比较复杂, 主要用来处理移进规约和跳转
    1. 根据 `yypact[yystate]`, 能够求出是否能够不进行 `lookahead` 就确定下一个状态, 
        - 如果可以就直接进入 `yydefault`, 就直接进入并处理. 这可由该句判断
            ```c
            yypact_value_is_default (yyn)
            ```
        - 否则要进行 `lookahead`, 通过多读入一个 `yychar`, 并转化为 `yytoken`. 然后用 `yycheck` 来确定有了这个 `yytoken` 之后, 能否就确定是否可使用 `yytable`.
            - 如果多读入的 `yytoken` 仍然没法解决问题, 就调用 `yydefault`
            - 如果能够使得程序规约(`yyreduce`)或检测出错误(`yyerrlab`), 则调到相应的代码.
        - 否则`yyn` 就必然是(0,YYLAST]之间的值, 于是移进预读的 `token`, 并进入`yynewstate`
4. 从步骤3可能进入以下几个处理代码段:
    - `yydefault`: 如果当前状态 `yystate` 的默认动作(`yydefact`) 为0则表示有错, 否则进入 `yyreduce`, 这时 `yyn` 表示用以规约的产生式序号
    - `yyreduce`: 这一步
        - 首先按照我们在 `.y` 文件中定义的规约规则执行 (对 `yyn` 作 `switch` 操作)
        - 然后决定 `goto` 哪个状态. 如果是不能确定的情况, 就要根据 `yydefgoto[yylhs]` 决定, 否则直接根据 `yytable[yyi]` 决定.
        - 最后 `goto yynewstate`
5. 其他还有一些错误处理和 `accept` 等简单状态, 暂时没时间看了.

### 参考资料

- [Understanding C parsers generated by GNU Bison](https://www.cs.uic.edu/~spopuri/cparser.html)

## 问题3

### 问题
请阅读`labBison/config/expr1.y`，并在`labBison/`下执行`make expr1`，然后检查输出的`src/expr1.output`，你将看到其中`State 11`和`State 24`还包含有冲突，请说明冲突的原因。

### 回答
#### 状态11

相关内容如下:
```bash
状态 11

   12 fact: MINUS fact .
   13     | fact . EXPON fact

    EXPON  偏移，并进入状态 18

    $default  使用规则 12 以归约 (fact)

    Conflict between rule 12 and token EXPON resolved as shift (MINUS < EXPON).
```
可见该冲突产生的原因是产生式12的规约与产生式13中 `EXPON` 的移进有移进-规约冲突.

#### 状态24

相关内容如下:
```bash
状态 24

   13 fact: fact . EXPON fact
   13     | fact EXPON fact .

    EXPON  偏移，并进入状态 18

    $default  使用规则 13 以归约 (fact)

    Conflict between rule 13 and token EXPON resolved as shift (%right EXPON).
```
可见该冲突产生的原因是产生式13的规约与产生式13中 `EXPON` 的移进有移进-规约冲突.

## 问题4

### 问题
请编写`labBison/config/expr1-s2.y`（已提供的内容与`labBison/config/expr1.y`一样），请修改文法使得用Bison处理后的`src/expr2.output`不再出现任何Conflict，在文档中说明你的解题思路。

### 回答
主要思路为: 
- 状态11和状态24的冲突都可由优先级解决. 于是我在 `fact` 和 `term` 中间加了一层表示指数的 `item`. (详见源码)
    ```c
    term    : term MULT item         { $$ = $1 * $3;   }
            | term DIV  item         { $$ = $1 / $3;   }
            | item                   { $$ = $1;        }
            ;
    item    : fact EXPON item       { $$ = pow($1, $3); }
            | fact                  { $$ = $1;      }
            ;
    fact    : NUMBER                { $$ = $1;        }
            | LB exp RB             { $$ = $2;        }
            | MINUS fact            { $$ = -$2;      }
            ;
    ```
    这样一来, 就利用语法规则把优先级间接实现了.
- 所不同之处在于, 
    - 解决状态11冲突的关键是把负号和指数的优先级分清: 这要求指数上和底数上都可以是一个 `fact`, 因为根据要求要使用 `L-expr`(举例而言-2**2应为4).
    - 解决状态24冲突的关键是确定好指数的右结合性: 这要求指数项还是个item.  
    用我这样的方法, 即使不声明 `EXPON` 的结合性, 也能够正确进行运算. 如 `-2**0.5**-1 = 4`.
> 注: 如要求使用 `python` 的方法(如-2**2=-4), 则把 `fact : MINUS fact` 挪到 `item` 里变成 `item : MINUS fact` 即可(详见之前的 git 版本)

## 问题5

### 问题
请自行用一个句子解释用生成的expr分析器分析的过程，分别基于`expr.y`和`expr1-s2.y`文法文件构造的分析器。

### 回答

根据刚才的构造, 就选一个比较有代表性的 `-2**0.5**-1 = 4`.
#### 对于 `expr.y`
由于 `expr.y` 给定了结合性和优先级, 
1. 这里 `-2` 中的 `-` 先和`2`结合(得出了-2),
2. 然后 `0.5` 和 `-1` 结合算指数得到 2, 
3. 最后得到了 `(-2)**2=4`

#### 对于 `expr1-s2.y`
不考虑优先级结合性, 只看语法就有:
1. `-2**0.5**-1` $\rightarrow$ `fact1**0.5**-1`, 其中 `fact1` 为 `-2`
2. `fact1**0.5**-1` $\rightarrow$ `fact1**item1`, 其中 `item1`=`fact2**fact3`(值为2), `fact2=0.5`, `fact3=-1`, 
3. `fact1**item1` $\rightarrow$ `item2`, 其中 `item2` 这时值为((-2)**2=4)
从而得到了结果.
